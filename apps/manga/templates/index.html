<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manga Recap Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .nav-home {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #ff6b6b !important;
            color: white !important;
            padding: 15px 25px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 9999 !important;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            border: 3px solid white;
            display: block;
        }

        .nav-home:hover {
            background: #ff5252 !important;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .upload-area {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: #667eea;
            background-color: #f7fafc;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background-color: #edf2f7;
        }

        #directUploadArea {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        #directUploadArea:hover {
            border-color: #667eea;
            background-color: #f7fafc;
        }

        #directUploadArea.dragover {
            border-color: #667eea;
            background-color: #edf2f7;
        }

        .workflow-option {
            padding: 25px;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .workflow-option:hover {
            border-color: #667eea;
            background-color: #f7fafc;
            transform: translateY(-2px);
        }

        .workflow-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .workflow-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .workflow-option h3 {
            margin: 15px 0 10px 0;
            font-size: 1.3rem;
        }

        .workflow-option p {
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .workflow-features {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.9rem;
        }

        .workflow-features span {
            opacity: 0.9;
        }

        .upload-icon {
            font-size: 3rem;
            color: #a0aec0;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .image-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-item {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .image-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }

        /* Smaller images for text extraction results */
        .text-results .image-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .text-results .image-item img {
            width: 100px;
            height: 80px;
            object-fit: cover;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .text-results .image-info {
            flex: 1;
            padding: 0;
        }

        .text-results .image-info h4 {
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .image-info {
            padding: 10px;
        }

        .image-info h4 {
            font-size: 0.9rem;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .text-content {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .editable-text {
            border: none;
            background: transparent;
            width: 100%;
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
        }

        .editable-text:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
            border-radius: 4px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Video Creation Styles */
        .video-options-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 20px 0;
        }

        .section {
            background: #f8fafc;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }

        .section h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .tts-options {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 5px 0;
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 33%, rgba(255,255,255,0.3) 33%, rgba(255,255,255,0.3) 66%, transparent 66%);
            animation: progressShimmer 2s infinite;
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-step {
            padding: 5px 0;
            color: #6b7280;
        }

        .progress-step.active {
            color: #10b981;
            font-weight: 600;
        }

        .progress-step.completed {
            color: #059669;
        }

        .progress-step.completed::before {
            content: '‚úÖ ';
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .btn-large {
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .api-keys-section {
            border-left: 4px solid #10b981;
        }

        .video-mode-selection button {
            transition: all 0.3s ease;
        }

        .video-mode-selection button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-weight: 500;
        }

        .alert-success {
            background-color: #f0fff4;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .alert-error {
            background-color: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }

        .recap-output {
            background: #f7fafc;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
        }

        .recap-editor {
            width: 100%;
            min-height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .recap-editor:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .recap-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .recap-actions button {
            flex: 1;
            min-width: 120px;
        }

        .edit-mode .recap-output {
            display: none;
        }

        .view-mode .recap-editor {
            display: none;
        }

        .save-status {
            color: #28a745;
            font-size: 14px;
            margin-left: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .save-status.show {
            opacity: 1;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            width: 0%;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .image-preview {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéå Manga Recap Generator</h1>
            <p>Upload manga images, extract text, and generate AI-powered recaps</p>
            <div style="text-align: center; margin: 20px 0;">
                <a href="../" style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 30px; text-decoration: none; border-radius: 25px; font-weight: bold; font-size: 16px; box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.5px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.6)'" onmouseout="this.style.transform='translateY(0px)'; this.style.boxShadow='0 5px 15px rgba(102, 126, 234, 0.4)'">‚Üê Back to Main Page</a>
            </div>
        </div>

        <!-- Step 1: Choose Workflow -->
        <div class="card">
            <h2>
                <span class="step-number">1</span>
                Choose Your Workflow
            </h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div class="workflow-option" onclick="selectWorkflow('extract')" id="extractWorkflow">
                    <div class="workflow-icon">üì±</div>
                    <h3>Extract from Images</h3>
                    <p>Upload manga images and let AI extract text automatically</p>
                    <div class="workflow-features">
                        <span>‚úì Auto text extraction</span>
                        <span>‚úì Character recognition</span>
                        <span>‚úì Scene analysis</span>
                    </div>
                </div>
                
                <div class="workflow-option" onclick="selectWorkflow('direct')" id="directWorkflow">
                    <div class="workflow-icon">üöÄ</div>
                    <h3>Direct Recap Generation</h3>
                    <p>Upload images and let Claude directly generate the recap</p>
                    <div class="workflow-features">
                        <span>‚úì Skip text extraction</span>
                        <span>‚úì Direct to recap</span>
                        <span>‚úì Faster workflow</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 2A: Upload Images (Extract Workflow) -->
        <div class="card" id="uploadCard" style="display: none;">
            <h2>
                <span class="step-number">2</span>
                Upload Manga Images
            </h2>
            
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="upload-icon">üìÅ</div>
                <h3>Click to select files or drag and drop</h3>
                <p>Support formats: PNG, JPG, JPEG, GIF, WebP</p>
                <p>Maximum 16MB per file ‚Ä¢ Maximum 70 files ‚Ä¢ 100MB total</p>
            </div>
            
            <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
            
            <div class="progress-bar hidden" id="uploadProgress">
                <div class="progress-fill" id="uploadProgressFill"></div>
            </div>
            
            <div id="uploadAlert"></div>
            
            <div id="imagePreview" class="image-preview"></div>
        </div>

        <!-- Step 2B: Direct Recap Generation (Direct Workflow) -->
        <div class="card" id="directInputCard" style="display: none;">
            <h2>
                <span class="step-number">2</span>
                Upload Images for Direct Recap
            </h2>
            
            <div class="upload-area" id="directUploadArea" onclick="document.getElementById('directFileInput').click()">
                <div class="upload-icon">üì∏</div>
                <h3>Upload manga images for direct recap generation</h3>
                <p>Claude will analyze your images and create a recap directly</p>
                <p>Support formats: PNG, JPG, JPEG, GIF, WebP</p>
                <p>Maximum 16MB per file ‚Ä¢ Maximum 70 files ‚Ä¢ 100MB total</p>
            </div>
            
            <input type="file" id="directFileInput" multiple accept="image/*" style="display: none;">
            
            <div class="progress-bar hidden" id="directUploadProgress">
                <div class="progress-fill" id="directUploadProgressFill"></div>
            </div>
            
            <div id="directUploadAlert"></div>
            
            <div id="directImagePreview" class="image-preview"></div>
            
            <!-- Direct Recap Generation Section -->
            <div id="directRecapSection" style="display: none; margin-top: 30px;">
                <h3>üéå Generate Recap with Claude</h3>
                <p style="color: #666; margin-bottom: 20px;">
                    <i class="fas fa-brain"></i> Powered by Claude AI with server-side configuration
                </p>
                
                <div class="form-group">
                    <label for="apiKey">Claude API Key:</label>
                    <input type="password" id="apiKey" class="form-control" 
                           placeholder="Enter your Claude API key (saved in session)">
                </div>
                
                <div class="form-group">
                    <label for="directCustomPrompt">Recap style (Optional):</label>
                    <textarea id="directCustomPrompt" class="form-control" 
                             placeholder="e.g., Make it dramatic, Focus on action, Keep it simple, etc."></textarea>
                </div>
                
                <button class="btn btn-primary" onclick="processDirectRecap()">
                    ‚ú® Generate Recap with Claude
                </button>
                
                <div class="loading" id="directRecapLoading">
                    <div class="spinner"></div>
                    <p>Claude is analyzing your images and creating the recap...</p>
                </div>
            </div>
        </div>

        <!-- Step 2: Extract and Edit Text -->
        <div class="card" id="extractCard" style="display: none;">
            <h2>
                <span class="step-number">3</span>
                Extract & Edit Text
            </h2>
            
            <button class="btn" id="extractBtn" onclick="extractText()">
                üîç Extract Text from Images
            </button>
            
            <div class="loading" id="extractLoading">
                <div class="spinner"></div>
                <p>Extracting text from images...</p>
            </div>
            
            <div id="textResults"></div>
        </div>

        <!-- Step 3: Generate Recap -->
        <div class="card" id="recapCard" style="display: none;">
            <h2>
                <span class="step-number">4</span>
            <h2 style="color: #4a5568; margin-bottom: 20px;">
                <i class="fas fa-robot"></i>
                Generate AI Recap
            </h2>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <i class="fas fa-info-circle" style="color: #1976d2;"></i>
                <strong>Server-side Processing:</strong> All AI processing happens on the server - no API keys needed!
            </div>
            
            <div class="form-group">
                <label for="customPrompt">Recap style (Optional):</label>
                <textarea id="customPrompt" class="form-control" 
                         placeholder="e.g., Make it exciting, Focus on characters, Keep it simple, etc."></textarea>
            </div>
            
            <button class="btn btn-secondary" id="generateBtn" onclick="generateRecap()">
                ‚ú® Generate Manga Recap
            </button>
            
            <div class="loading" id="recapLoading">
                <div class="spinner"></div>
                <p>Generating your manga recap...</p>
            </div>
            
            <div id="recapResult"></div>
        </div>

        <!-- Step 4: Advanced Video Creation -->
        <div class="card" id="videoCard" style="display: none;">
            <h2>
                <span class="step-number">5</span>
                üé¨ Create Your Video
            </h2>
            
            <!-- Video Creation Mode Selection -->
            <div class="video-mode-selection" style="margin-bottom: 30px;">
                <h3>Choose Creation Method:</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                    <button class="btn btn-primary" id="openaiVideoBtn" onclick="showOpenAIVideoCreation()" style="padding: 20px; background: #059669; border: 2px solid #10b981;">
                        üöÄ HD Video (OpenAI Enhanced)
                        <br><small style="opacity: 0.9;">‚ú® Guaranteed Audio ‚Ä¢ Auto-fallback TTS ‚Ä¢ HD Quality</small>
                    </button>
                    <button class="btn btn-primary" id="liveVideoBtn" onclick="showLiveVideoCreation()" style="padding: 20px; background: #10b981;">
                        ‚ö° Standard Video Creation
                        <br><small style="opacity: 0.8;">üîä Reliable Audio ‚Ä¢ Windows Edge TTS Backup</small>
                    </button>
                    <button class="btn btn-secondary" id="downloadPackageBtn" onclick="showPackageOptions()" style="padding: 20px;">
                        üì¶ Download Package
                        <br><small style="opacity: 0.8;">Traditional download method</small>
                    </button>
                </div>
            </div>

            <!-- OpenAI Enhanced Video Creation Interface -->
            <div id="openaiVideoInterface" style="display: none;">
                <div class="alert alert-success">
                    <h4>üöÄ OpenAI Enhanced Video Creation</h4>
                    <p>This method uses OpenAI's high-quality TTS with automatic Windows Edge TTS fallback for guaranteed audio generation.</p>
                    <ul>
                        <li>‚ú® HD TTS Audio (tts-1-hd model with auto-fallback)</li>
                        <li>üîä 100% Audio Success Rate (Windows Edge TTS backup)</li>
                        <li>üé® Enhanced blur backgrounds</li>
                        <li>üìê Optimized image composition</li>
                        <li>üé¨ High-quality video encoding</li>
                    </ul>
                </div>
                
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 25px; text-align: center;">
                    <h3 style="margin: 0 0 10px 0; font-size: 24px;">üöÄ Premium HD Video Creation</h3>
                    <p style="margin: 0; opacity: 0.9; font-size: 16px;">Professional quality videos with OpenAI's advanced TTS technology</p>
                </div>
                
                <div style="background: white; border: 2px solid #e3f2fd; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                        <div style="background: #2196f3; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; font-size: 18px;">‚ú®</div>
                        <div>
                            <h4 style="margin: 0; color: #1976d2;">Premium Features</h4>
                            <p style="margin: 0; color: #666; font-size: 14px;">OpenAI HD TTS ‚Ä¢ 720p Quality ‚Ä¢ Smart Audio Fallback</p>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 8px;">
                            <strong style="color: #2196f3;">üé§ Audio Quality</strong><br>
                            <span style="color: #666; font-size: 14px;">OpenAI tts-1-hd with Windows backup</span>
                        </div>
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 8px;">
                            <strong style="color: #2196f3;">üé¨ Video Quality</strong><br>
                            <span style="color: #666; font-size: 14px;">HD 720p with enhanced processing</span>
                        </div>
                    </div>
                </div>

                <div style="text-align: center; margin: 30px 0;">
                    <button id="createOpenAIVideoBtn" class="btn btn-primary btn-large" onclick="createOpenAIVideo()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: 15px 30px; font-size: 18px; border-radius: 25px; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
                        üöÄ Create Premium HD Video
                    </button>
                    <br><br>
                    <button id="testOpenAIBtn" class="btn btn-info" onclick="testOpenAIConnection()" style="margin-top: 10px; background: #17a2b8; border: none; padding: 10px 20px; border-radius: 20px;">
                        üß™ Test OpenAI Connection
                    </button>
                    <br>
                    <button id="checkVideoBtn" class="btn btn-warning" onclick="manualVideoCheck()" style="margin-top: 10px; background: #ffc107; color: #000; border: none; padding: 10px 20px; border-radius: 20px; display: none;">
                        üîç Check for Completed Video
                    </button>
                </div>
                
                <!-- Progress for OpenAI Video -->
                <div id="openaiVideoProgress" style="display: none;">
                    <h3>üöÄ Creating Your HD Video...</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div id="openaiProgressFill" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <p id="openaiProgressText" class="progress-text">Initializing...</p>
                    </div>
                    
                    <div class="progress-steps">
                        <div id="openaiStep1" class="progress-step">üîß Preparing components</div>
                        <div id="openaiStep2" class="progress-step">üé§ Generating HD audio (with backup)</div>
                        <div id="openaiStep3" class="progress-step">üé® Processing images</div>
                        <div id="openaiStep4" class="progress-step">üé¨ Creating video</div>
                        <div id="openaiStep5" class="progress-step">‚ú® Finalizing</div>
                    </div>
                </div>
                
                <!-- OpenAI Video Result -->
                <div id="openaiVideoResult" style="display: none;">
                    <h3>üéâ Your HD Video with Audio is Ready!</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <video id="openaiVideoPlayer" controls preload="metadata" style="width: 100%; max-width: 800px; height: auto; min-height: 400px; border-radius: 10px; background: #000;">
                            <source id="openaiVideoSource" src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <br>
                        <div style="margin-top: 10px;">
                            <button onclick="document.getElementById('openaiVideoPlayer').requestFullscreen()" style="margin: 5px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üî≤ Fullscreen</button>
                            <button onclick="document.getElementById('openaiVideoPlayer').volume = document.getElementById('openaiVideoPlayer').volume > 0 ? 0 : 0.8" style="margin: 5px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üîä Toggle Sound</button>
                        </div>
                    </div>
                    
                    <div class="video-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div class="stat-card">
                            <strong>Duration:</strong><br>
                            <span id="openaiResultDuration">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>Quality:</strong><br>
                            <span id="openaiResultQuality">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>File Size:</strong><br>
                            <span id="openaiResultFileSize">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>Audio:</strong><br>
                            <span id="openaiResultAudio">‚úÖ Guaranteed HD Audio</span>
                        </div>
                    </div>
                    
                    <div class="video-actions" style="text-align: center; margin: 20px 0;">
                        <button id="downloadOpenAIVideoBtn" class="btn btn-success" onclick="downloadOpenAIVideo()" style="font-size: 18px; padding: 15px 30px; margin: 10px; background: #28a745; border: 2px solid #28a745; box-shadow: 0 4px 8px rgba(40,167,69,0.3);">
                            üì• Download HD Video
                        </button>
                        <br>
                        <button class="btn btn-info" onclick="shareOpenAIVideo()" style="margin: 5px;">
                            üîó Share Video
                        </button>
                        <button class="btn btn-secondary" onclick="createAnotherOpenAIVideo()" style="margin: 5px;">
                            üîÑ Create Another
                        </button>
                    </div>
                </div>
            </div>

            <!-- Live Video Creation Interface -->
            <div id="liveVideoInterface" style="display: none;">
                <div class="video-options-container">
                    <!-- TTS Provider Selection -->
                    <div class="section">
                        <h3>üé§ Voice & Audio Settings</h3>
                        <div class="alert alert-success" style="margin-bottom: 15px; padding: 10px; background: #e8f5e8; border: 1px solid #4caf50;">
                            <strong>üîä Guaranteed Audio:</strong> All TTS providers now include automatic Windows Edge TTS fallback to ensure no silent videos!
                        </div>
                        <div class="form-group">
                            <label for="ttsProvider">TTS Provider:</label>
                            <select id="ttsProvider" class="form-control" onchange="updateTTSOptions()">
                                <option value="openai">OpenAI TTS (Auto-fallback enabled)</option>
                                <option value="elevenlabs">ElevenLabs (Auto-fallback enabled)</option>
                                <option value="azure">Azure Speech Services (Auto-fallback enabled)</option>
                                <option value="google">Google Cloud TTS (Auto-fallback enabled)</option>
                                <option value="manual">No TTS (Silent Video)</option>
                            </select>
                        </div>

                        <!-- OpenAI TTS Options -->
                        <div id="openaiOptions" class="tts-options">
                            <div class="alert alert-info" style="margin-bottom: 15px; padding: 10px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 6px;">
                                <small>‚úÖ <strong>Server-side processing:</strong> No API key needed! OpenAI TTS is handled automatically.</small>
                            </div>
                            <div class="form-group">
                                <label for="openaiVoice">OpenAI Voice:</label>
                                <select id="openaiVoice" class="form-control">
                                    <option value="alloy">Alloy (Neutral, Clear)</option>
                                    <option value="echo">Echo (Male, Warm)</option>
                                    <option value="fable">Fable (British Male)</option>
                                    <option value="onyx">Onyx (Deep Male)</option>
                                    <option value="nova">Nova (Female, Expressive)</option>
                                    <option value="shimmer">Shimmer (Soft Female)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="openaiSpeed">Speech Speed:</label>
                                <select id="openaiSpeed" class="form-control">
                                    <option value="0.8">Slow (0.8x)</option>
                                    <option value="1.0" selected>Normal (1.0x)</option>
                                    <option value="1.2">Fast (1.2x)</option>
                                </select>
                            </div>
                        </div>

                        <!-- ElevenLabs Options -->
                        <div id="elevenlabsOptions" class="tts-options" style="display: none;">
                            <div class="form-group">
                                <label for="elevenlabsKey">ElevenLabs API Key:</label>
                                <input type="password" id="elevenlabsKey" class="form-control" placeholder="Enter ElevenLabs API key">
                            </div>
                            <div class="form-group">
                                <label for="elevenlabsVoice">Voice:</label>
                                <select id="elevenlabsVoice" class="form-control">
                                    <option value="Rachel">Rachel (Calm Female)</option>
                                    <option value="Drew">Drew (Well-rounded Male)</option>
                                    <option value="Clyde">Clyde (War Veteran Male)</option>
                                    <option value="Paul">Paul (Ground Reporter Male)</option>
                                    <option value="Domi">Domi (Strong Female)</option>
                                    <option value="Dave">Dave (Conversational Male)</option>
                                    <option value="Fin">Fin (Old Man)</option>
                                    <option value="Sarah">Sarah (Soft Female)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Video Settings -->
                    <div class="section">
                        <h3>üé• Video Configuration</h3>
                        <div class="form-group">
                            <label for="platformOptimization">Platform Optimization:</label>
                            <select id="platformOptimization" class="form-control" onchange="updateVideoSettings()">
                                <option value="youtube">YouTube (16:9 Landscape)</option>
                                <option value="tiktok">TikTok/Instagram Reels (9:16 Vertical)</option>
                                <option value="instagram">Instagram Post (1:1 Square)</option>
                                <option value="twitter">Twitter Video (16:9)</option>
                                <option value="facebook">Facebook (16:9)</option>
                                <option value="custom">Custom Settings</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="videoQuality">Video Quality:</label>
                            <select id="videoQuality" class="form-control">
                                <option value="480">SD (480p) - Faster</option>
                                <option value="720" selected>HD (720p) - Recommended</option>
                                <option value="1080">Full HD (1080p) - Best Quality</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="frameDuration">Frame Duration:</label>
                            <select id="frameDuration" class="form-control">
                                <option value="auto" selected>Auto (Based on text length)</option>
                                <option value="3">3 seconds per frame</option>
                                <option value="4">4 seconds per frame</option>
                                <option value="5">5 seconds per frame</option>
                                <option value="6">6 seconds per frame</option>
                                <option value="8">8 seconds per frame</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Additional Features:</label>
                            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="includeSubtitles" checked> Include subtitles
                                </label>
                                <label class="checkbox-label">
                                    <input type="checkbox" id="includeTransitions"> Smooth transitions between images
                                </label>
                                <label class="checkbox-label">
                                    <input type="checkbox" id="includeBackgroundMusic"> Background music
                                </label>
                                <label class="checkbox-label">
                                    <input type="checkbox" id="addWatermark"> Add watermark
                                </label>
                            </div>
                        </div>

                        <div class="form-group" id="backgroundMusicOptions" style="display: none;">
                            <label for="musicType">Background Music Type:</label>
                            <select id="musicType" class="form-control">
                                <option value="epic">Epic/Cinematic</option>
                                <option value="calm">Calm/Ambient</option>
                                <option value="dramatic">Dramatic</option>
                                <option value="upbeat">Upbeat</option>
                                <option value="dark">Dark/Mysterious</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Server Processing Notice -->
                <div class="api-keys-section" style="margin: 30px 0; padding: 20px; background: #f0f9ff; border-radius: 10px;">
                    <h3> Ô∏è Server-side AI Processing</h3>
                    <div style="background: #e0f2fe; padding: 15px; border-radius: 8px;">
                        <i class="fas fa-server" style="color: #0277bd; font-size: 1.2em;"></i>
                        <strong style="color: #0277bd;">All AI processing happens on the server</strong>
                        <p style="margin: 10px 0 0 0; color: #0288d1;">
                            No need to provide API keys - TTS generation and video creation are handled server-side with optimized settings.
                        </p>
                    </div>
                    
                    <!-- Enhanced Features Notice -->
                    <div style="margin-top: 15px; padding: 15px; background: #ecfdf5; border-radius: 8px; border-left: 4px solid #10b981;">
                        <h4 style="color: #059669; margin-bottom: 10px;">üÜï Enhanced Features!</h4>
                        <ul style="color: #047857; margin: 0; padding-left: 20px;">
                            <li><strong>üéµ HD Audio Narration:</strong> Premium TTS-1-HD generation</li>
                            <li><strong>üåü Optimized Visuals:</strong> Light blur backgrounds with 95% image size</li>
                            <li><strong>üé¨ Professional Quality:</strong> Enhanced visual composition</li>
                            <li><strong>‚ö° Streamlined Process:</strong> No configuration needed</li>
                        </ul>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="button-group" style="margin: 30px 0;">
                    <button id="createLiveVideoBtn" class="btn btn-primary btn-large" onclick="createLiveVideo()">
                        üé¨ Create Video Now
                    </button>
                    <button id="previewVideoBtn" class="btn btn-secondary" onclick="previewVideo()">
                        üëÅÔ∏è Preview (First 30 seconds)
                    </button>
                </div>

                <!-- Live Video Progress -->
                <div id="liveVideoProgress" style="display: none;">
                    <h3>üîÑ Creating Your Video...</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div id="liveProgressFill" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div id="liveProgressText">Initializing...</div>
                    </div>
                    <div id="liveProgressSteps" style="margin-top: 15px; font-size: 0.9em; color: #6b7280;">
                        <div class="progress-step" id="step1">‚è≥ Preparing segments...</div>
                        <div class="progress-step" id="step2">üîä Generating audio (guaranteed)</div>
                        <div class="progress-step" id="step3">‚è≥ Processing images...</div>
                        <div class="progress-step" id="step4">‚è≥ Creating video...</div>
                        <div class="progress-step" id="step5">‚è≥ Finalizing...</div>
                    </div>
                </div>

                <!-- Video Result -->
                <div id="liveVideoResult" style="display: none;">
                    <h3>üéâ Your Video is Ready!</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <video id="resultVideoPlayer" controls playsinline style="width: 100%; max-width: 800px; height: auto; min-height: 400px; border-radius: 10px; background: #000;">
                            <source id="resultVideoSource" src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <br>
                        <button onclick="document.getElementById('resultVideoPlayer').requestFullscreen()" style="margin: 5px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üî≤ Fullscreen</button>
                        <button onclick="testVideoAudio()" style="margin: 5px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üîä Test Audio</button>
                        <button onclick="downloadLiveVideo()" style="margin: 5px; padding: 10px 20px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">üíæ Download</button>
                    </div>
                    
                    <div class="video-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div class="stat-card">
                            <strong>Duration:</strong><br>
                            <span id="resultDuration">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>Quality:</strong><br>
                            <span id="resultQuality">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>File Size:</strong><br>
                            <span id="resultFileSize">-</span>
                        </div>
                        <div class="stat-card">
                            <strong>Audio:</strong><br>
                            <span id="resultAudio">üîä Guaranteed</span>
                        </div>
                        <div class="stat-card">
                            <strong>Format:</strong><br>
                            <span id="resultFormat">MP4</span>
                        </div>
                    </div>

                    <div class="button-group">
                        <button id="downloadLiveVideoBtn" class="btn btn-success" onclick="downloadLiveVideo()">
                            üíæ Download Video
                        </button>
                        <button id="shareVideoBtn" class="btn btn-primary" onclick="shareVideo()">
                            üì§ Share Video
                        </button>
                        <button id="createAnotherBtn" class="btn btn-secondary" onclick="resetVideoCreation()">
                            üîÑ Create Another Video
                        </button>
                    </div>
                </div>
            </div>

            <!-- Package Download Options (Original) -->
            <div id="packageInterface" style="display: none;">
                <div class="video-options" style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px;">
                    <button class="btn" onclick="generateVideoScript()">
                        üé¨ Generate Video Script
                    </button>
                    <button class="btn btn-primary" onclick="createAutomatedVideo()" style="background: #10b981;">
                        ü§ñ Create Automated Video Package
                    </button>
                    <button class="btn btn-secondary" onclick="exportForVideo()" id="exportBtn" style="display: none;">
                        üì¶ Export Manual Video Package
                    </button>
                    <button class="btn btn-secondary" onclick="downloadVideoPackage()" id="downloadPackageBtn" style="display: none;">
                        üì• Download Manual Package
                    </button>
                    <button class="btn btn-secondary" onclick="downloadAutomatedPackage()" id="downloadAutomatedBtn" style="display: none;">
                        üöÄ Download Automated Package
                    </button>
                </div>
                
                <div class="alert alert-success" style="margin-bottom: 15px; padding: 15px; background: #e8f5e8; border-radius: 8px; border-left: 4px solid #4caf50;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <span style="font-weight: 600; color: #2d7d32;">‚úÖ Server-Side Processing</span>
                    </div>
                    <div style="font-size: 0.9em; color: #388e3c;">
                        All OpenAI TTS and video processing happens automatically on the server using pre-configured API keys. No manual configuration needed!
                    </div>
                </div>
            </div>
            
            <div class="loading" id="videoLoading">
                <div class="spinner"></div>
                <p>Creating video production script...</p>
            </div>
            
            <div id="videoResult"></div>
            
            <div class="video-guide" style="margin-top: 20px; padding: 20px; background: #f7fafc; border-radius: 10px; display: none;" id="videoGuide">
                <h3>üé• Video Creation Options:</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;">
                    <div class="option-card" style="padding: 15px; background: #ecfdf5; border-radius: 8px; border: 2px solid #10b981;">
                        <h4 style="color: #059669; margin-bottom: 10px;">ü§ñ Automated Pipeline (NEW!)</h4>
                        <p><strong>Features:</strong> TTS generation, auto image matching, ready-to-run Python script</p>
                        <p><strong>Process:</strong> Click button ‚Üí Download package ‚Üí Run script ‚Üí Get MP4</p>
                        <p><strong>Best for:</strong> Complete automation, no manual work</p>
                        <p style="color: #047857; font-weight: 600; margin-top: 10px;">‚úÖ Fully automated video creation!</p>
                    </div>
                    <div class="option-card" style="padding: 15px; background: white; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <h4 style="color: #2d3748; margin-bottom: 10px;">  Online Tools</h4>
                        <p><strong>Tools:</strong> Pictory.ai, Lumen5, InVideo</p>
                        <p><strong>Process:</strong> Upload script ‚Üí Add images ‚Üí Auto-generate video</p>
                        <p><strong>Best for:</strong> Quick, no software installation</p>
                    </div>
                    <div class="option-card" style="padding: 15px; background: white; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <h4 style="color: #2d3748; margin-bottom: 10px;"> Ô∏è Professional Editing</h4>
                        <p><strong>Tools:</strong> ElevenLabs + DaVinci Resolve</p>
                        <p><strong>Process:</strong> Generate voice ‚Üí Edit with panels ‚Üí Add effects</p>
                        <p><strong>Best for:</strong> Professional quality, full control</p>
                    </div>
                </div>
            </div>
            
        </div>

        <!-- Help Section -->
        <div class="card">
            <h2>üí° Tips for Best Results</h2>
            <ul style="line-height: 1.8; color: #4a5568;">
                <li><strong>Image Quality:</strong> Use clear, high-resolution manga images</li>
                <li><strong>Order:</strong> Upload images in reading order (page 1, 2, 3...)</li>
                <li><strong>Keep it Simple:</strong> Let Claude focus on the story - simple instructions work best</li>
                <li><strong>Style Notes:</strong> Use short, clear style instructions like "make it exciting" or "focus on action"</li>
                <li><strong>AI Processing:</strong> Powered by Claude AI with server-side configuration for seamless processing</li>
            </ul>
        </div>
    </div>

    <script>
        let uploadedFiles = [];
        let sessionId = null;
        let currentSessionId = null;
        let extractedTexts = [];
        let selectedWorkflow = null;

        // Workflow selection functions
        function selectWorkflow(workflow) {
            selectedWorkflow = workflow;
            
            // Update visual selection
            document.querySelectorAll('.workflow-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.getElementById(workflow + 'Workflow').classList.add('selected');
            
            // Show appropriate next step
            if (workflow === 'extract') {
                document.getElementById('uploadCard').style.display = 'block';
                document.getElementById('directInputCard').style.display = 'none';
            } else if (workflow === 'direct') {
                document.getElementById('uploadCard').style.display = 'none';
                document.getElementById('directInputCard').style.display = 'block';
                // Generate a session ID for direct workflow
                currentSessionId = 'direct_' + Date.now();
            }
        }

        // Direct workflow upload functionality
        const directUploadArea = document.getElementById('directUploadArea');
        const directFileInput = document.getElementById('directFileInput');

        // Add event listeners when elements exist
        if (directUploadArea && directFileInput) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                directUploadArea.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                directUploadArea.addEventListener(eventName, () => directUploadArea.classList.add('dragover'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                directUploadArea.addEventListener(eventName, () => directUploadArea.classList.remove('dragover'), false);
            });

            directUploadArea.addEventListener('drop', handleDirectDrop, false);
            directFileInput.addEventListener('change', handleDirectFiles, false);
        }

        // Regular workflow upload functionality
        // Add event listeners for regular upload when elements exist
        if (document.getElementById('fileInput')) {
            document.getElementById('fileInput').addEventListener('change', handleRegularFiles, false);
        }

        function handleRegularFiles(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Validate file types
            const invalidFiles = files.filter(file => {
                const validTypes = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif', 'image/webp'];
                return !validTypes.includes(file.type);
            });

            if (invalidFiles.length > 0) {
                showAlert('uploadAlert', 
                    `Invalid file types: ${invalidFiles.map(f => f.name).join(', ')}. Only PNG, JPG, JPEG, GIF, WebP are allowed.`, 
                    'error');
                return;
            }

            uploadFiles(files);
        }

        function handleDirectDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleDirectFiles({ target: { files } });
        }

        function handleDirectFiles(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Validate file types
            const invalidFiles = files.filter(file => {
                const validTypes = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif', 'image/webp'];
                return !validTypes.includes(file.type);
            });

            if (invalidFiles.length > 0) {
                showAlert('directUploadAlert', 
                    `Invalid file types: ${invalidFiles.map(f => f.name).join(', ')}. Only PNG, JPG, JPEG, GIF, WebP are allowed.`, 
                    'error');
                return;
            }

            uploadDirectFiles(files);
            // Show the recap section after files are selected
            document.getElementById('directRecapSection').style.display = 'block';
        }

        async function uploadDirectFiles(files) {
            // Validate files before upload
            if (files.length > 70) {
                showAlert('directUploadAlert', 'Too many files selected. Maximum 70 files allowed.', 'error');
                return;
            }
            
            let totalSize = 0;
            const validFiles = [];
            
            for (const file of files) {
                if (file.size > 16 * 1024 * 1024) {
                    showAlert('directUploadAlert', `File ${file.name} is too large (max 16MB)`, 'error');
                    return;
                }
                totalSize += file.size;
                if (totalSize > 100 * 1024 * 1024) {
                    showAlert('directUploadAlert', 'Total file size too large (max 100MB total)', 'error');
                    return;
                }
                validFiles.push(file);
            }

            const formData = new FormData();
            validFiles.forEach(file => {
                formData.append('files', file);
            });

            const progressBar = document.getElementById('directUploadProgress');
            const progressFill = document.getElementById('directUploadProgressFill');
            
            progressBar.classList.remove('hidden');
            progressFill.style.width = '0%';

            try {
                // Simulate progress
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 10;
                    progressFill.style.width = progress + '%';
                    if (progress >= 90) clearInterval(interval);
                }, 200);

                const response = await fetch('/manga/upload', {
                    method: 'POST',
                    body: formData
                });

                clearInterval(interval);
                progressFill.style.width = '100%';

                const data = await response.json();
                
                // Debug logging
                console.log('Upload response:', response);
                console.log('Upload data:', data);
                console.log('Data.files:', data.files);

                if (response.ok) {
                    uploadedFiles = data.files;
                    sessionId = data.session_id;
                    currentSessionId = data.session_id;
                    window.currentSessionId = data.session_id; // Set global variable for video creation
                    showAlert('directUploadAlert', data.message, 'success');
                    displayDirectImagePreviews(data.files);
                    document.getElementById('directRecapSection').style.display = 'block';
                } else {
                    showAlert('directUploadAlert', data.error || 'Upload failed', 'error');
                }
            } catch (error) {
                console.error('Direct upload error:', error);
                showAlert('directUploadAlert', 'Upload failed: ' + error.message, 'error');
            } finally {
                setTimeout(() => {
                    progressBar.classList.add('hidden');
                }, 1000);
            }
        }

        function displayDirectImagePreviews(files) {
            const preview = document.getElementById('directImagePreview');
            preview.innerHTML = '';

            // Safety check for undefined files
            if (!files || !Array.isArray(files)) {
                console.error('displayDirectImagePreviews called with invalid files:', files);
                return;
            }

            files.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.innerHTML = `
                    <img src="${file.url}" alt="${file.filename}" loading="lazy">
                    <div class="image-info">
                        <h4>üìÑ ${file.filename}</h4>
                        <small>Page ${index + 1}</small>
                    </div>
                `;
                preview.appendChild(div);
            });
        }

        // Direct recap processing function
        async function processDirectRecap() {
            const customPrompt = document.getElementById('directCustomPrompt').value.trim();

            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const loading = document.getElementById('directRecapLoading');
            const btn = event.target;
            
            loading.classList.add('show');
            btn.disabled = true;

            try {
                // Sort files by filename to ensure chronological order
                const sortedFiles = [...uploadedFiles].sort((a, b) => {
                    const getOriginalName = (filename) => {
                        return filename.replace(/_\d{8}_\d{6}/, '');
                    };
                    
                    const nameA = getOriginalName(a.filename).toLowerCase();
                    const nameB = getOriginalName(b.filename).toLowerCase();
                    
                    return nameA.localeCompare(nameB, undefined, {
                        numeric: true,
                        sensitivity: 'base'
                    });
                });

                // Extract text from images first, then generate recap
                const extractResponse = await fetch('/manga/extract-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        files: sortedFiles
                    })
                });

                const extractData = await extractResponse.json();
                
                if (!extractResponse.ok) {
                    throw new Error(extractData.error || 'Failed to extract text from images');
                }

                const extractedTexts = extractData.results.map(result => result.text);

                // Generate recap directly
                const recapResponse = await fetch('/manga/generate-recap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        texts: extractedTexts,
                        prompt: customPrompt
                    })
                });

                const recapData = await recapResponse.json();
                
                if (recapResponse.ok) {
                    // Display the recap result in a dedicated section for direct workflow
                    displayDirectRecapResult(recapData.recap);
                } else {
                    throw new Error(recapData.error || 'Failed to generate recap');
                }
            } catch (error) {
                alert('Error generating recap: ' + error.message);
            } finally {
                loading.classList.remove('show');
                btn.disabled = false;
            }
        }

        // Function to display recap result for direct workflow
        function displayDirectRecapResult(recap) {
            // Create or update the direct recap result section
            let resultContainer = document.getElementById('directRecapResult');
            if (!resultContainer) {
                resultContainer = document.createElement('div');
                resultContainer.id = 'directRecapResult';
                document.getElementById('directInputCard').appendChild(resultContainer);
            }

            resultContainer.innerHTML = `
                <div style="margin-top: 30px; padding: 20px; background: #f0f9ff; border-radius: 10px; border-left: 4px solid #0ea5e9;">
                    <h3 style="margin-bottom: 15px; color: #0c4a6e;">üéå Your Generated Recap:</h3>
                    <div class="recap-container view-mode" id="directRecapContainer">
                        <div class="recap-output" id="directRecapOutput" style="display: block; background: white; padding: 20px; border-radius: 8px; line-height: 1.6;">${recap.replace(/\n/g, '<br>')}</div>
                        <textarea class="recap-editor" id="directRecapEditor" style="display: none; min-height: 300px;">${recap}</textarea>
                        <div class="recap-actions" style="margin-top: 15px;">
                            <button class="btn" onclick="toggleDirectEditMode()" id="directEditToggleBtn">
                                ‚úèÔ∏è Edit Recap
                            </button>
                            <button class="btn btn-secondary" onclick="saveDirectRecap()" style="display: none;" id="directSaveBtn">
                                üíæ Save Changes
                            </button>
                            <button class="btn" onclick="copyDirectRecap()">
                                üìã Copy Recap
                            </button>
                            <button class="btn btn-success" onclick="proceedToVideoCreation()" style="margin-left: 10px;">
                                üé¨ Create Video
                            </button>
                        </div>
                        <span class="save-status" id="directSaveStatus" style="display: none; color: #059669; font-weight: 600;">Saved successfully!</span>
                    </div>
                </div>
            `;
        }

        // Toggle edit mode for direct recap
        function toggleDirectEditMode() {
            const container = document.getElementById('directRecapContainer');
            const editBtn = document.getElementById('directEditToggleBtn');
            const saveBtn = document.getElementById('directSaveBtn');
            const recapOutput = document.getElementById('directRecapOutput');
            const recapEditor = document.getElementById('directRecapEditor');
            
            if (container.classList.contains('view-mode')) {
                // Switch to edit mode
                container.classList.remove('view-mode');
                container.classList.add('edit-mode');
                editBtn.innerHTML = 'üëÄ View Mode';
                saveBtn.style.display = 'inline-block';
                
                recapOutput.style.display = 'none';
                recapEditor.style.display = 'block';
                recapEditor.focus();
            } else {
                // Switch to view mode
                container.classList.remove('edit-mode');
                container.classList.add('view-mode');
                editBtn.innerHTML = '‚úèÔ∏è Edit Recap';
                saveBtn.style.display = 'none';
                
                recapOutput.style.display = 'block';
                recapEditor.style.display = 'none';
                
                // Update the output with any changes from the editor
                recapOutput.innerHTML = recapEditor.value.replace(/\n/g, '<br>');
            }
        }

        // Save direct recap changes
        async function saveDirectRecap() {
            const editor = document.getElementById('directRecapEditor');
            const saveStatus = document.getElementById('directSaveStatus');
            const saveBtn = document.getElementById('directSaveBtn');
            
            if (!currentSessionId) {
                alert('No session found.');
                return;
            }
            
            try {
                saveBtn.disabled = true;
                saveBtn.innerHTML = 'üíæ Saving...';
                
                const response = await fetch('/manga/update-recap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        recap: editor.value,
                        session_id: currentSessionId
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    saveStatus.style.display = 'inline';
                    setTimeout(() => {
                        saveStatus.style.display = 'none';
                    }, 3000);
                } else {
                    throw new Error(data.error || 'Failed to save recap');
                }
            } catch (error) {
                alert('Error saving recap: ' + error.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Save Changes';
            }
        }

        // Copy direct recap to clipboard
        function copyDirectRecap() {
            const container = document.getElementById('directRecapContainer');
            let textToCopy;
            
            if (container.classList.contains('edit-mode')) {
                const editor = document.getElementById('directRecapEditor');
                textToCopy = editor.value;
            } else {
                const output = document.getElementById('directRecapOutput');
                textToCopy = output.innerText || output.textContent;
            }
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                alert('Recap copied to clipboard!');
            }).catch(err => {
                console.error('Copy failed:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Recap copied to clipboard!');
            });
        }

        // Proceed to video creation from direct workflow
        function proceedToVideoCreation() {
            // Get the current recap text
            const container = document.getElementById('directRecapContainer');
            let currentRecap;
            
            if (container.classList.contains('edit-mode')) {
                currentRecap = document.getElementById('directRecapEditor').value;
            } else {
                currentRecap = document.getElementById('directRecapOutput').innerText || document.getElementById('directRecapOutput').textContent;
            }
            
            // Store the recap in the main recap result section for video creation
            displayRecapResult(currentRecap);
            
            // Show video creation card
            document.getElementById('videoCard').style.display = 'block';
            
            // Scroll to video creation section
            document.getElementById('videoCard').scrollIntoView({ behavior: 'smooth' });
        }

        // Drag and drop functionality
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
        });

        uploadArea.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles({ target: { files } });
        }

        function handleFiles(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Validate file types
            const invalidFiles = files.filter(file => {
                const validTypes = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif', 'image/webp'];
                return !validTypes.includes(file.type);
            });

            if (invalidFiles.length > 0) {
                showAlert('uploadAlert', 
                    `Invalid file types: ${invalidFiles.map(f => f.name).join(', ')}. Only PNG, JPG, JPEG, GIF, WebP are allowed.`, 
                    'error');
                return;
            }

            uploadFiles(files);
        }

        async function uploadFiles(files) {
            // Validate files before upload
            if (files.length > 70) {
                showAlert('uploadAlert', 'Too many files selected. Maximum 70 files allowed.', 'error');
                return;
            }
            
            let totalSize = 0;
            const validFiles = [];
            
            for (const file of files) {
                if (file.size > 16 * 1024 * 1024) {
                    showAlert('uploadAlert', `File ${file.name} is too large (max 16MB)`, 'error');
                    return;
                }
                totalSize += file.size;
                if (totalSize > 100 * 1024 * 1024) {
                    showAlert('uploadAlert', 'Total file size too large (max 100MB total)', 'error');
                    return;
                }
                validFiles.push(file);
            }

            const formData = new FormData();
            validFiles.forEach(file => {
                formData.append('files', file);
            });

            const progressBar = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('uploadProgressFill');
            
            progressBar.classList.remove('hidden');
            progressFill.style.width = '0%';

            try {
                // Simulate progress
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 10;
                    progressFill.style.width = progress + '%';
                    if (progress >= 90) clearInterval(interval);
                }, 200);

                const response = await fetch('/manga/upload', {
                    method: 'POST',
                    body: formData
                });

                clearInterval(interval);
                progressFill.style.width = '100%';

                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('Server returned non-JSON response:', text);
                    throw new Error('Server error: Expected JSON response but got HTML. Check server logs.');
                }

                const data = await response.json();

                if (response.ok) {
                    uploadedFiles = data.files;
                    sessionId = data.session_id;
                    currentSessionId = data.session_id;
                    window.currentSessionId = data.session_id; // Set global variable for video creation
                    showAlert('uploadAlert', data.message, 'success');
                    displayImagePreviews(data.files);
                    document.getElementById('extractCard').style.display = 'block';
                } else {
                    showAlert('uploadAlert', data.error || 'Upload failed', 'error');
                }
            } catch (error) {
                console.error('Upload error:', error);
                showAlert('uploadAlert', 'Upload failed: ' + error.message, 'error');
            } finally {
                setTimeout(() => {
                    progressBar.classList.add('hidden');
                }, 1000);
            }
        }

        function displayImagePreviews(files) {
            const preview = document.getElementById('imagePreview');
            preview.innerHTML = '';

            // Safety check for undefined files
            if (!files || !Array.isArray(files)) {
                console.error('displayImagePreviews called with invalid files:', files);
                return;
            }

            files.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.innerHTML = `
                    <img src="${file.url}" alt="${file.filename}" loading="lazy">
                    <div class="image-info">
                        <h4>üìÑ ${file.filename}</h4>
                        <small>Page ${index + 1}</small>
                    </div>
                `;
                preview.appendChild(div);
            });
        }

        async function extractText() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const loading = document.getElementById('extractLoading');
            const btn = document.getElementById('extractBtn');
            
            loading.classList.add('show');
            btn.disabled = true;

            try {
                // Sort files by filename to ensure chronological order for video narration
                const sortedFiles = [...uploadedFiles].sort((a, b) => {
                    // Extract the original filename (before timestamp) for proper sorting
                    const getOriginalName = (filename) => {
                        // Remove timestamp suffix like "_20250825_123456"
                        return filename.replace(/_\d{8}_\d{6}/, '');
                    };
                    
                    const nameA = getOriginalName(a.filename).toLowerCase();
                    const nameB = getOriginalName(b.filename).toLowerCase();
                    
                    // Natural sort for better numerical ordering (page1, page2, page10, etc.)
                    return nameA.localeCompare(nameB, undefined, {
                        numeric: true,
                        sensitivity: 'base'
                    });
                });

                const response = await fetch('/manga/extract-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ files: sortedFiles })
                });

                const data = await response.json();
                
                if (response.ok) {
                    extractedTexts = data.results.map(result => result.text);
                    displayTextResults(data.results);
                    document.getElementById('recapCard').style.display = 'block';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error extracting text: ' + error.message);
            } finally {
                loading.classList.remove('show');
                btn.disabled = false;
            }
        }

        function displayTextResults(results) {
            const container = document.getElementById('textResults');
            container.innerHTML = '<h3 style="margin: 20px 0;">Extracted Text (Click to edit):</h3>';
            container.className = 'text-results';

            results.forEach((result, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';
                div.innerHTML = `
                    <img src="${result.url}" alt="${result.filename}" loading="lazy">
                    <div class="image-info">
                        <h4>üìÑ ${result.filename}</h4>
                        <div class="text-content">
                            <textarea class="editable-text" 
                                      data-index="${index}" 
                                      onchange="updateExtractedText(${index}, this.value)"
                                      placeholder="No text extracted or click to edit...">${result.text || ''}</textarea>
                        </div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function updateExtractedText(index, newText) {
            extractedTexts[index] = newText;
        }

        async function generateRecap() {
            const customPrompt = document.getElementById('customPrompt').value.trim();

            if (extractedTexts.length === 0) {
                alert('Please extract text first');
                return;
            }

            const loading = document.getElementById('recapLoading');
            const btn = document.getElementById('generateBtn');
            
            loading.classList.add('show');
            btn.disabled = true;

            try {
                const response = await fetch('/manga/generate-recap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        texts: extractedTexts,
                        prompt: customPrompt
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    displayRecapResult(data.recap);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error generating recap: ' + error.message);
            } finally {
                loading.classList.remove('show');
                btn.disabled = false;
            }
        }

        function displayRecapResult(recap) {
            // Set global variables for video creation
            window.currentRecap = recap;
            if (currentSessionId) {
                window.currentSessionId = currentSessionId;
            }
            
            const container = document.getElementById('recapResult');
            container.innerHTML = `
                <h3 style="margin-bottom: 15px;">üéå Your Manga Recap:</h3>
                <div class="recap-container view-mode" id="recapContainer">
                    <div class="recap-output" id="recapOutput" style="display: block;">${recap.replace(/\n/g, '<br>')}</div>
                    <textarea class="recap-editor" id="recapEditor" style="display: none;">${recap}</textarea>
                    <div class="recap-actions">
                        <button class="btn" onclick="toggleEditMode()" id="editToggleBtn">
                            ‚úèÔ∏è Edit Recap
                        </button>
                        <button class="btn btn-secondary" onclick="saveRecap()" style="display: none;" id="saveBtn">
                            üíæ Save Changes
                        </button>
                        <button class="btn" onclick="copyRecap()">
                            üìã Copy Recap
                        </button>
                        <button class="btn btn-secondary" onclick="downloadRecap()" id="downloadBtn" style="display: none;">
                            üì• Download
                        </button>
                    </div>
                    <span class="save-status" id="saveStatus">Saved successfully!</span>
                </div>
            `;
            
            // Show video creation card
            document.getElementById('videoCard').style.display = 'block';
        }

        function toggleEditMode() {
            const container = document.getElementById('recapContainer');
            const editBtn = document.getElementById('editToggleBtn');
            const saveBtn = document.getElementById('saveBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const recapOutput = document.getElementById('recapOutput');
            const recapEditor = document.getElementById('recapEditor');
            
            if (container.classList.contains('view-mode')) {
                // Switch to edit mode
                container.classList.remove('view-mode');
                container.classList.add('edit-mode');
                editBtn.innerHTML = 'üëÄ View Mode';
                saveBtn.style.display = 'block';
                downloadBtn.style.display = 'none';
                
                // Manually show/hide elements
                recapOutput.style.display = 'none';
                recapEditor.style.display = 'block';
                recapEditor.focus();
            } else {
                // Switch to view mode
                container.classList.remove('edit-mode');
                container.classList.add('view-mode');
                editBtn.innerHTML = '‚úèÔ∏è Edit Recap';
                saveBtn.style.display = 'none';
                downloadBtn.style.display = 'block';
                
                // Manually show/hide elements
                recapOutput.style.display = 'block';
                recapEditor.style.display = 'none';
                
                // Update the output with any changes from the editor
                recapOutput.innerHTML = recapEditor.value.replace(/\n/g, '<br>');
            }
        }

        async function saveRecap() {
            const editor = document.getElementById('recapEditor');
            const saveStatus = document.getElementById('saveStatus');
            const saveBtn = document.getElementById('saveBtn');
            
            if (!currentSessionId) {
                alert('No session found. Please upload files first.');
                return;
            }
            
            try {
                saveBtn.disabled = true;
                saveBtn.innerHTML = 'üíæ Saving...';
                
                const response = await fetch('/manga/update-recap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        recap: editor.value,
                        session_id: currentSessionId
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Update global recap variable with the new content
                    window.currentRecap = editor.value;
                    
                    saveStatus.classList.add('show');
                    setTimeout(() => {
                        saveStatus.classList.remove('show');
                    }, 3000);
                    
                    // Enable download button
                    document.getElementById('downloadBtn').style.display = 'block';
                } else {
                    throw new Error(data.error || 'Failed to save recap');
                }
            } catch (error) {
                alert('Error saving recap: ' + error.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'üíæ Save Changes';
            }
        }

        async function downloadRecap() {
            if (!currentSessionId) {
                alert('No session found. Please save the recap first.');
                return;
            }
            
            try {
                const response = await fetch(`/download-recap/${currentSessionId}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `manga_recap_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to download recap');
                }
            } catch (error) {
                alert('Error downloading recap: ' + error.message);
            }
        }

        function copyRecap() {
            const container = document.getElementById('recapContainer');
            let textToCopy;
            
            if (container.classList.contains('edit-mode')) {
                const editor = document.getElementById('recapEditor');
                textToCopy = editor.value;
            } else {
                const output = document.getElementById('recapOutput');
                textToCopy = output.innerText || output.textContent;
            }
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                alert('Recap copied to clipboard!');
            }).catch(err => {
                console.error('Copy failed:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Recap copied to clipboard!');
            });
        }

        function showAlert(containerId, message, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = `
                <div class="alert alert-${type}">
                    ${message}
                </div>
            `;
            
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }

        // Auto-save API key in session
        document.getElementById('apiKey').addEventListener('input', function(e) {
            sessionStorage.setItem('claude-api-key', e.target.value);
        });

        // Load saved API key
        window.addEventListener('load', function() {
            const savedKey = sessionStorage.getItem('claude-api-key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }
        });

        // Video creation functions
        let currentVideoScript = '';

        async function generateVideoScript() {
            if (extractedTexts.length === 0) {
                alert('Please extract text first');
                return;
            }

            const loading = document.getElementById('videoLoading');
            const btn = event.target;
            
            loading.classList.add('show');
            btn.disabled = true;

            try {
                const apiKey = document.getElementById('apiKey').value || '';
                const customPrompt = document.getElementById('customPrompt').value;

                const response = await fetch('/manga/generate-video-script', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        texts: extractedTexts,
                        prompt: customPrompt,
                        api_key: apiKey
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    currentVideoScript = data.video_script;
                    displayVideoScript(data.video_script);
                    document.getElementById('exportBtn').style.display = 'block';
                    document.getElementById('videoGuide').style.display = 'block';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error generating video script: ' + error.message);
            } finally {
                loading.classList.remove('show');
                btn.disabled = false;
            }
        }

        function displayVideoScript(script) {
            const container = document.getElementById('videoResult');
            container.innerHTML = `
                <h3 style="margin-bottom: 15px;">üé¨ Video Production Script:</h3>
                <div class="script-output" style="background: #f7fafc; border-radius: 10px; padding: 25px; margin-top: 20px; line-height: 1.6; white-space: pre-wrap; max-height: 500px; overflow-y: auto;">
                    ${script.replace(/\n/g, '<br>')}
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn" onclick="copyVideoScript()">
                        üìã Copy Script
                    </button>
                </div>
            `;
        }

        function copyVideoScript() {
            navigator.clipboard.writeText(currentVideoScript).then(() => {
                alert('Video script copied to clipboard!');
            }).catch(err => {
                console.error('Copy failed:', err);
                alert('Failed to copy script');
            });
        }

        async function exportForVideo() {
            if (!currentSessionId) {
                alert('No session found. Please upload files first.');
                return;
            }

            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üì¶ Exporting...';

            try {
                const recapText = document.getElementById('recapEditor') ? 
                    document.getElementById('recapEditor').value : 
                    document.getElementById('recapOutput').textContent;

                const response = await fetch('/manga/export-for-video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        recap: recapText,
                        video_script: currentVideoScript
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    alert('Video package exported successfully!');
                    document.getElementById('downloadPackageBtn').style.display = 'block';
                } else {
                    throw new Error(data.error || 'Failed to export');
                }
            } catch (error) {
                alert('Error exporting: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üì¶ Export Video Package';
            }
        }

        async function downloadVideoPackage() {
            if (!currentSessionId) {
                alert('No session found.');
                return;
            }
            
            try {
                const response = await fetch(`/download-video-export/${currentSessionId}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `manga_video_package_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to download');
                }
            } catch (error) {
                alert('Error downloading: ' + error.message);
            }
        }

        // Automated video creation functions
        async function createAutomatedVideo() {
            let currentRecap = '';
            
            // Method 1: Try to get from the editor textarea (hidden but contains text)
            const recapEditor = document.getElementById('recapEditor');
            if (recapEditor && recapEditor.value && recapEditor.value.trim()) {
                currentRecap = recapEditor.value.trim();
                console.log('Found recap in recapEditor:', currentRecap.length, 'characters');
            }
            
            // Method 2: Try to get from the display div (convert HTML back to text)
            if (!currentRecap) {
                const recapOutput = document.getElementById('recapOutput');
                if (recapOutput && recapOutput.innerHTML && recapOutput.innerHTML.trim()) {
                    // Convert HTML content back to plain text
                    currentRecap = recapOutput.innerHTML
                        .replace(/<br\s*\/?>/gi, '\n')  // Convert <br> tags to newlines
                        .replace(/<[^>]*>/g, '')        // Remove all other HTML tags
                        .replace(/&nbsp;/g, ' ')        // Convert &nbsp; to spaces
                        .replace(/&amp;/g, '&')        // Convert &amp; to &
                        .replace(/&lt;/g, '<')         // Convert &lt; to <
                        .replace(/&gt;/g, '>')         // Convert &gt; to >
                        .trim();
                    console.log('Found recap in recapOutput:', currentRecap.length, 'characters');
                }
            }
            
            // Method 3: Final fallback - search for any textarea in the recap area
            if (!currentRecap) {
                const textarea = document.querySelector('#recapResult textarea, .recap-editor');
                if (textarea && textarea.value && textarea.value.trim()) {
                    currentRecap = textarea.value.trim();
                    console.log('Found recap in fallback textarea:', currentRecap.length, 'characters');
                }
            }
            
            console.log('Recap detection result:', {
                found: !!currentRecap,
                length: currentRecap.length,
                preview: currentRecap.substring(0, 100) + (currentRecap.length > 100 ? '...' : '')
            });
            
            if (!currentRecap || currentRecap.length < 50) {
                alert('Please generate a recap first. The recap needs to be at least 50 characters long.');
                return;
            }
            
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üîÑ Creating Video Package...';
            
            try {
                const response = await fetch('/manga/create-automated-video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        recap: currentRecap
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Show success message with details
                    const resultDiv = document.getElementById('videoResult');
                    resultDiv.innerHTML = `
                        <div style="background: #ecfdf5; border: 1px solid #10b981; border-radius: 10px; padding: 20px; margin-top: 20px;">
                            <h3 style="color: #059669; margin-bottom: 15px;">üéâ Automated Video Package Created!</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                <div style="background: white; padding: 15px; border-radius: 8px;">
                                    <div style="font-weight: 600; color: #047857;">Audio Files Generated</div>
                                    <div style="font-size: 1.5em; color: #059669;">${data.audio_files_generated}</div>
                                </div>
                                <div style="background: white; padding: 15px; border-radius: 8px;">
                                    <div style="font-weight: 600; color: #047857;">Text Segments</div>
                                    <div style="font-size: 1.5em; color: #059669;">${data.total_segments}</div>
                                </div>
                                <div style="background: white; padding: 15px; border-radius: 8px;">
                                    <div style="font-weight: 600; color: #047857;">Estimated Duration</div>
                                    <div style="font-size: 1.5em; color: #059669;">${data.estimated_duration}</div>
                                </div>
                            </div>
                            <div style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <h4 style="color: #0c4a6e; margin-bottom: 10px;">üì¶ Package Contents:</h4>
                                <ul style="color: #0369a1; margin: 0; padding-left: 20px;">
                                    <li>Generated audio files (MP3) for each text segment</li>
                                    <li>Python script for automatic video creation</li>
                                    <li>Image-to-audio mapping file</li>
                                    <li>All your manga images</li>
                                    <li>Complete usage instructions</li>
                                </ul>
                            </div>
                            <div style="background: #fef3c7; padding: 15px; border-radius: 8px; border-left: 4px solid #f59e0b;">
                                <h4 style="color: #92400e; margin-bottom: 10px;">üöÄ Next Steps:</h4>
                                <ol style="color: #92400e; margin: 0; padding-left: 20px;">
                                    <li>Download the package below</li>
                                    <li>Install moviepy: <code style="background: #fff; padding: 2px 6px; border-radius: 4px;">pip install moviepy pillow numpy</code></li>
                                    <li>Run the script: <code style="background: #fff; padding: 2px 6px; border-radius: 4px;">python video_creation_script.py</code></li>
                                    <li>Your video will be created automatically!</li>
                                </ol>
                            </div>
                        </div>
                    `;
                    
                    // Show download button
                    document.getElementById('downloadAutomatedBtn').style.display = 'block';
                    
                    // Show video guide
                    document.getElementById('videoGuide').style.display = 'block';
                    
                } else {
                    throw new Error(data.error || 'Failed to create automated video package');
                }
            } catch (error) {
                alert('Error creating automated video: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ü§ñ Create Automated Video Package';
            }
        }

        async function downloadAutomatedPackage() {
            if (!currentSessionId) {
                alert('No session found.');
                return;
            }
            
            try {
                const response = await fetch(`/download-automated-video/${currentSessionId}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `automated_manga_video_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to download');
                }
            } catch (error) {
                alert('Error downloading automated package: ' + error.message);
            }
        }

        // Live Video Creation Functions
        function showLiveVideoCreation() {
            document.getElementById('liveVideoInterface').style.display = 'block';
            document.getElementById('packageInterface').style.display = 'none';
            document.getElementById('liveVideoBtn').style.background = '#10b981';
            document.getElementById('downloadPackageBtn').style.background = '#6b7280';
        }

        function showPackageOptions() {
            document.getElementById('liveVideoInterface').style.display = 'none';
            document.getElementById('packageInterface').style.display = 'block';
            document.getElementById('liveVideoBtn').style.background = '#6b7280';
            document.getElementById('downloadPackageBtn').style.background = '#10b981';
        }

        function updateTTSOptions() {
            const provider = document.getElementById('ttsProvider').value;
            document.getElementById('openaiOptions').style.display = provider === 'openai' ? 'block' : 'none';
            document.getElementById('elevenlabsOptions').style.display = provider === 'elevenlabs' ? 'block' : 'none';
        }

        function updateVideoSettings() {
            const platform = document.getElementById('platformOptimization').value;
            const qualitySelect = document.getElementById('videoQuality');
            
            // Update quality options based on platform
            switch(platform) {
                case 'tiktok':
                    qualitySelect.innerHTML = `
                        <option value="720">HD (720p) - Recommended for TikTok</option>
                        <option value="1080">Full HD (1080p) - Best Quality</option>
                    `;
                    break;
                case 'instagram':
                    qualitySelect.innerHTML = `
                        <option value="720">HD (720p) - Recommended</option>
                        <option value="1080">Full HD (1080p) - Best Quality</option>
                    `;
                    break;
                default:
                    qualitySelect.innerHTML = `
                        <option value="480">SD (480p) - Faster</option>
                        <option value="720" selected>HD (720p) - Recommended</option>
                        <option value="1080">Full HD (1080p) - Best Quality</option>
                    `;
            }
        }

        // Toggle background music options
        document.getElementById('includeBackgroundMusic').addEventListener('change', function() {
            document.getElementById('backgroundMusicOptions').style.display = this.checked ? 'block' : 'none';
        });

        async function createLiveVideo() {
            try {
                // Validate inputs
                if (!currentSessionId) {
                    alert('Please upload images and generate a recap first');
                    return;
                }

                // Get current recap text properly
                let currentRecap = '';
                
                // Method 1: Try to get from the editor textarea (hidden but contains text)
                const recapEditor = document.getElementById('recapEditor');
                if (recapEditor && recapEditor.value && recapEditor.value.trim()) {
                    currentRecap = recapEditor.value.trim();
                    console.log('Found recap in recapEditor:', currentRecap.length, 'characters');
                }
                
                // Method 2: Try to get from the display div (convert HTML back to text)
                if (!currentRecap) {
                    const recapOutput = document.getElementById('recapOutput');
                    if (recapOutput && recapOutput.innerHTML && recapOutput.innerHTML.trim()) {
                        currentRecap = recapOutput.innerHTML
                            .replace(/<br\s*\/?>/gi, '\n')
                            .replace(/<[^>]*>/g, '')
                            .replace(/&nbsp;/g, ' ')
                            .replace(/&amp;/g, '&')
                            .replace(/&lt;/g, '<')
                            .replace(/&gt;/g, '>')
                            .trim();
                        console.log('Found recap in recapOutput:', currentRecap.length, 'characters');
                    }
                }
                
                // Method 3: Try direct workflow recap
                if (!currentRecap) {
                    const directRecapEditor = document.getElementById('directRecapEditor');
                    if (directRecapEditor && directRecapEditor.value && directRecapEditor.value.trim()) {
                        currentRecap = directRecapEditor.value.trim();
                        console.log('Found recap in directRecapEditor:', currentRecap.length, 'characters');
                    }
                }
                
                // Method 4: Try direct recap output
                if (!currentRecap) {
                    const directRecapOutput = document.getElementById('directRecapOutput');
                    if (directRecapOutput && directRecapOutput.textContent && directRecapOutput.textContent.trim()) {
                        currentRecap = directRecapOutput.textContent.trim();
                        console.log('Found recap in directRecapOutput:', currentRecap.length, 'characters');
                    }
                }

                if (!currentRecap) {
                    alert('Please generate a recap first. No recap text found.');
                    return;
                }

                console.log('Using recap with', currentRecap.length, 'characters for video creation');

                // Show progress
                document.getElementById('liveVideoProgress').style.display = 'block';
                document.getElementById('liveVideoResult').style.display = 'none';
                document.getElementById('createLiveVideoBtn').disabled = true;

                // Collect settings (simplified for server-side processing)
                const settings = {
                    session_id: currentSessionId,
                    recap: currentRecap,
                    video_quality: document.getElementById('videoQuality').value,
                    platform: document.getElementById('platformOptimization').value,
                    frame_duration: document.getElementById('frameDuration').value,
                    include_subtitles: document.getElementById('includeSubtitles').checked,
                    include_transitions: document.getElementById('includeTransitions').checked,
                    include_background_music: document.getElementById('includeBackgroundMusic').checked,
                    music_type: document.getElementById('musicType').value,
                    add_watermark: document.getElementById('addWatermark').checked
                };

                // Update progress steps
                updateProgressStep(1, 'active');
                updateProgress(10, 'Preparing video segments...');

                const response = await fetch('/manga/create-live-video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(settings)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleProgressUpdate(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Video creation error:', error);
                alert('Error creating video: ' + error.message);
                document.getElementById('createLiveVideoBtn').disabled = false;
                document.getElementById('liveVideoProgress').style.display = 'none';
            }
        }

        function handleProgressUpdate(data) {
            if (data.progress) {
                updateProgress(data.progress, data.message || '');
            }

            if (data.step) {
                updateProgressStep(data.step, 'active');
                if (data.step > 1) {
                    updateProgressStep(data.step - 1, 'completed');
                }
            }

            if (data.complete && data.video_url) {
                showVideoResult(data);
            }

            if (data.package_ready && data.alternative) {
                // Handle alternative package creation
                showAlternativeResult(data);
            }

            if (data.error) {
                alert('Video creation failed: ' + data.error);
                document.getElementById('createLiveVideoBtn').disabled = false;
                document.getElementById('liveVideoProgress').style.display = 'none';
            }
        }

        function showAlternativeResult(data) {
            document.getElementById('liveVideoProgress').style.display = 'none';
            document.getElementById('liveVideoResult').style.display = 'block';
            
            // Update the result section for package download
            const resultSection = document.getElementById('liveVideoResult');
            resultSection.innerHTML = `
                <h3>üì¶ Video Package Created!</h3>
                <div class="alert alert-info">
                    <strong>MoviePy Installation Issue Detected</strong><br>
                    We've created a complete video creation package for you instead. This includes:
                    <ul>
                        <li>‚úÖ Audio files with TTS narration</li>
                        <li>‚úÖ Python script for video creation</li>
                        <li>‚úÖ All your manga images</li>
                        <li>‚úÖ Step-by-step instructions</li>
                    </ul>
                </div>
                
                <div class="package-actions">
                    <a href="${data.download_url}" class="btn btn-primary btn-large">
                        üì• Download Video Package
                    </a>
                    <button onclick="showMoviePyInstructions()" class="btn btn-secondary">
                        üîß Fix MoviePy (Optional)
                    </button>
                </div>
                
                <div id="moviepyInstructions" style="display: none; margin-top: 20px;">
                    <div class="alert alert-warning">
                        <h4>To Fix MoviePy for Future Videos:</h4>
                        <p>Run these commands in your terminal:</p>
                        <code>
                            pip uninstall moviepy imageio<br>
                            pip install moviepy==1.0.3 imageio==2.8.0
                        </code>
                        <p><small>After fixing, restart the app to use live video creation.</small></p>
                    </div>
                </div>
            `;
            
            document.getElementById('createLiveVideoBtn').disabled = false;
        }

        function showMoviePyInstructions() {
            document.getElementById('moviepyInstructions').style.display = 'block';
        }

        function updateProgress(percentage, message) {
            document.getElementById('liveProgressFill').style.width = percentage + '%';
            document.getElementById('liveProgressText').textContent = message;
        }

        function updateProgressStep(stepNumber, status) {
            const step = document.getElementById('step' + stepNumber);
            if (step) {
                step.className = 'progress-step ' + status;
                
                const messages = {
                    1: '‚è≥ Preparing segments...',
                    2: 'üîä Generating audio (auto-fallback enabled)...',
                    3: '‚è≥ Processing images...',
                    4: '‚è≥ Creating video...',
                    5: '‚è≥ Finalizing...'
                };

                if (status === 'completed') {
                    step.textContent = messages[stepNumber].replace('‚è≥', '‚úÖ');
                } else if (status === 'active') {
                    step.textContent = messages[stepNumber].replace('‚è≥', 'üîÑ');
                }
            }
        }

        function showVideoResult(data) {
            document.getElementById('liveVideoProgress').style.display = 'none';
            document.getElementById('liveVideoResult').style.display = 'block';
            
            // Set video source with proper loading
            const videoPlayer = document.getElementById('resultVideoPlayer');
            const videoSource = document.getElementById('resultVideoSource');
            
            // Add timestamp to prevent caching issues
            const videoUrl = data.video_url + '?t=' + Date.now();
            videoSource.src = videoUrl;
            
            // Ensure video loads properly
            videoPlayer.load();
            
            // Explicitly enable audio
            videoPlayer.muted = false;
            videoPlayer.volume = 0.8;
            
            // Add error handling for video loading
            videoPlayer.onerror = function(e) {
                console.error('Video loading error:', e);
                alert('Error loading video. Please check if the video file was created properly.');
            };
            
            // Set video dimensions explicitly
            videoPlayer.style.width = '100%';
            videoPlayer.style.height = 'auto';
            videoPlayer.style.minHeight = '400px';
            videoPlayer.style.maxWidth = '800px';
            
            // Try to load metadata
            videoPlayer.addEventListener('loadedmetadata', function() {
                console.log('Video metadata loaded successfully');
                console.log('Video dimensions:', videoPlayer.videoWidth, 'x', videoPlayer.videoHeight);
                console.log('Video duration:', videoPlayer.duration);
                
                // Check if video has audio tracks
                const audioTracks = videoPlayer.audioTracks ? videoPlayer.audioTracks.length : 'Unknown';
                console.log('Audio tracks:', audioTracks);
                
                // Additional audio debugging
                console.log('Video muted:', videoPlayer.muted);
                console.log('Video volume:', videoPlayer.volume);
            });
            
            videoPlayer.addEventListener('canplay', function() {
                console.log('Video can start playing');
                
                // Show a user-friendly message about audio
                if (!videoPlayer.muted && videoPlayer.volume > 0) {
                    console.log('‚úÖ Audio should be enabled');
                } else {
                    console.log('‚ö†Ô∏è Audio may be disabled');
                }
            });

            // Update stats
            document.getElementById('resultDuration').textContent = data.duration || '-';
            document.getElementById('resultQuality').textContent = data.quality || '-';
            document.getElementById('resultFileSize').textContent = data.file_size || '-';
            
            // Show which TTS method was actually used
            let audioStatus = 'üîä Guaranteed Audio';
            if (data.tts_method) {
                if (data.tts_method === 'edge') {
                    audioStatus = 'üîä Windows Edge TTS (Fallback)';
                } else if (data.tts_method === 'openai') {
                    audioStatus = '‚ú® OpenAI TTS (Primary)';
                } else if (data.tts_method === 'elevenlabs') {
                    audioStatus = 'üéµ ElevenLabs TTS (Premium)';
                } else {
                    audioStatus = `üé§ ${data.tts_method} TTS`;
                }
            }
            document.getElementById('resultAudio').textContent = audioStatus;

            // Store video URL for download
            window.currentVideoUrl = videoUrl;
            
            document.getElementById('createLiveVideoBtn').disabled = false;
        }

        async function previewVideo() {
            // Create a 30-second preview
            alert('Preview feature coming soon! This will create a 30-second preview of your video.');
        }

        function testVideoAudio() {
            const videoPlayer = document.getElementById('resultVideoPlayer');
            
            console.log('=== VIDEO AUDIO DEBUG ===');
            console.log('Video source:', videoPlayer.src);
            console.log('Video muted:', videoPlayer.muted);
            console.log('Video volume:', videoPlayer.volume);
            console.log('Video readyState:', videoPlayer.readyState);
            console.log('Video duration:', videoPlayer.duration);
            
            // Try to unmute and set volume
            videoPlayer.muted = false;
            videoPlayer.volume = 1.0;
            
            // Try to play from the beginning
            videoPlayer.currentTime = 0;
            
            videoPlayer.play().then(() => {
                alert('‚úÖ Video is playing with audio enabled. If you still can\'t hear audio, the video file might not contain audio tracks.');
            }).catch((error) => {
                console.error('Play failed:', error);
                alert('‚ùå Failed to play video: ' + error.message);
            });
        }

        function downloadLiveVideo() {
            if (window.currentVideoUrl) {
                const a = document.createElement('a');
                a.href = window.currentVideoUrl;
                a.download = 'manga_video_' + new Date().toISOString().slice(0,10) + '.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        function shareVideo() {
            if (navigator.share && window.currentVideoUrl) {
                navigator.share({
                    title: 'My Manga Recap Video',
                    text: 'Check out this manga recap video I created!',
                    url: window.currentVideoUrl
                });
            } else {
                // Fallback - copy URL to clipboard
                navigator.clipboard.writeText(window.currentVideoUrl).then(() => {
                    alert('Video URL copied to clipboard!');
                });
            }
        }

        function resetVideoCreation() {
            document.getElementById('liveVideoResult').style.display = 'none';
            document.getElementById('liveVideoProgress').style.display = 'none';
            document.getElementById('createLiveVideoBtn').disabled = false;
            
            // Reset progress
            updateProgress(0, 'Ready to create video...');
            for (let i = 1; i <= 5; i++) {
                updateProgressStep(i, '');
            }
        }

        // Initialize video creation interface
        document.addEventListener('DOMContentLoaded', function() {
            // Show live video creation by default
            showLiveVideoCreation();
        });

        // OpenAI Enhanced Video Creation Functions
        function showOpenAIVideoCreation() {
            document.getElementById('openaiVideoInterface').style.display = 'block';
            document.getElementById('liveVideoInterface').style.display = 'none';
        }

        function hideOpenAIVideoCreation() {
            document.getElementById('openaiVideoInterface').style.display = 'none';
            document.getElementById('openaiVideoProgress').style.display = 'none';
            document.getElementById('openaiVideoResult').style.display = 'none';
        }

        async function createOpenAIVideo() {
            console.log('ÔøΩ HD Video button clicked - FULL DEBUG MODE');
            console.log('Current recap exists:', !!window.currentRecap);
            console.log('Current session ID exists:', !!window.currentSessionId);
            console.log('Recap content preview:', window.currentRecap ? window.currentRecap.substring(0, 100) + '...' : 'NONE');
            console.log('Session ID value:', window.currentSessionId || 'NONE');
            
            // Initialize completion tracking
            window.openaiVideoCompleted = false;
            
            // Clear any existing video to prevent confusion with old cached content
            const existingVideoPlayer = document.getElementById('openaiVideoPlayer');
            const existingVideoSource = document.getElementById('openaiVideoSource');
            if (existingVideoPlayer && existingVideoSource) {
                console.log('üßπ Clearing existing video to prevent cache conflicts...');
                existingVideoPlayer.pause();
                existingVideoPlayer.removeAttribute('src');
                existingVideoSource.removeAttribute('src');
                existingVideoPlayer.load();
                
                // Hide result section to avoid showing old video
                document.getElementById('openaiVideoResult').style.display = 'none';
            }
            
            // Check if button is disabled
            const button = document.getElementById('createOpenAIVideoBtn');
            console.log('Button disabled state:', button ? button.disabled : 'BUTTON NOT FOUND');
            
            if (!window.currentRecap) {
                console.error('‚ùå Missing recap - showing alert');
                alert('Please generate a recap first! Go to the recap section and create a recap from your uploaded images.');
                return;
            }

            if (!window.currentSessionId) {
                console.error('‚ùå Missing session ID - showing alert');
                alert('Please upload images first! Go to the upload section and upload your manga images.');
                return;
            }

            console.log('‚úÖ Prerequisites met - starting video creation');

            try {
                console.log('üìù Disabling button and showing progress');
                document.getElementById('createOpenAIVideoBtn').disabled = true;
                document.getElementById('openaiVideoProgress').style.display = 'block';
                document.getElementById('openaiVideoResult').style.display = 'none';

                const requestData = {
                    session_id: window.currentSessionId,
                    recap: window.currentRecap
                };
                
                console.log('üöÄ Sending request to /create-openai-video with data:', {
                    session_id: requestData.session_id,
                    recap_length: requestData.recap.length
                });

                console.log('üì° Making fetch request...');
                // Send data via POST and handle streaming response
                const response = await fetch('/manga/create-openai-video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('üì° Received response:', response.status, response.statusText);
                console.log('üì° Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Response not OK:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }
                
                console.log('‚úÖ Response OK - getting reader');
                const reader = response.body.getReader();
                console.log('‚úÖ Reader obtained, starting stream processing...');
                
                function readStream() {
                    console.log('üîÑ Reading stream chunk...');
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            console.log('‚úÖ Stream reading completed - checking if video was created');
                            
                            // If stream ends without completion, show error
                            if (!window.openaiVideoCompleted) {
                                console.error('‚ùå Stream ended without completion event');
                                alert('Video creation stream ended unexpectedly. Click "Check for Completed Video" below if you see "Moviepy - Done!" in the terminal.');
                                document.getElementById('createOpenAIVideoBtn').disabled = false;
                                document.getElementById('openaiVideoProgress').style.display = 'none';
                                document.getElementById('checkVideoBtn').style.display = 'block'; // Show manual check button
                            }
                            return;
                        }
                        
                        console.log('üì¶ Received chunk, size:', value.byteLength);
                        const chunk = new TextDecoder().decode(value);
                        console.log('üì¶ Decoded chunk:', chunk);
                        
                        // Handle empty chunks gracefully
                        if (!chunk.trim()) {
                            console.log('üì¶ Empty chunk received, continuing...');
                            return readStream();
                        }
                        
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const jsonData = line.slice(6).trim();
                                    if (!jsonData) {
                                        console.log('üì¶ Empty JSON data, skipping...');
                                        continue;
                                    }
                                    
                                    const data = JSON.parse(jsonData);
                                    console.log('üìä Parsed SSE data:', data);
                                    
                                    // ENHANCED: Check for completion specifically
                                    if (data.complete === true) {
                                        console.log('üéâ VIDEO COMPLETION DETECTED!', data);
                                        console.log('üé¨ Video URL:', data.video_url);
                                        window.openaiVideoCompleted = true;
                                    }
                                    
                                    handleOpenAIProgressUpdate(data);
                                } catch (e) {
                                    console.error('‚ùå Error parsing SSE data:', e, 'Line:', line);
                                    // Don't stop the stream for parsing errors, just log them
                                }
                            }
                        }
                        
                        return readStream();
                    }).catch(error => {
                        console.error('‚ùå Error reading stream:', error);
                        
                        // Check if this is a network error or stream end
                        if (error.name === 'AbortError' || error.message.includes('aborted')) {
                            console.log('üîÑ Stream was aborted, this might be normal');
                        } else {
                            console.error('üí• Unexpected stream error:', error);
                            alert('Network error during video creation: ' + error.message + '\n\nPlease check your connection and try again.');
                            document.getElementById('createOpenAIVideoBtn').disabled = false;
                            document.getElementById('openaiVideoProgress').style.display = 'none';
                        }
                        
                        throw error;
                    });
                }
                
                await readStream();
                
                // FALLBACK: If stream ends without completion, check if video was actually created
                if (!window.openaiVideoCompleted) {
                    console.log('üîÑ Stream ended without completion event, checking for video...');
                    setTimeout(async () => {
                        try {
                            const checkResponse = await fetch(`/manga/uploads/${window.currentSessionId}/manga_video.mp4`, {
                                method: 'HEAD'
                            });
                            
                            if (checkResponse.ok) {
                                console.log('üéâ FALLBACK: Video file found! Showing result manually...');
                                const videoUrl = `/manga/uploads/${window.currentSessionId}/manga_video.mp4`;
                                showOpenAIVideoResult({
                                    video_url: videoUrl,
                                    complete: true,
                                    duration: 'Unknown',
                                    quality: 'HD',
                                    file_size: 'Unknown',
                                    audio_quality: 'HD TTS',
                                    tts_method: 'openai',
                                    enhanced: true
                                });
                            } else {
                                console.log('‚ùå FALLBACK: No video file found');
                                alert('Video creation may have failed. Please check the server logs and try again.');
                                document.getElementById('createOpenAIVideoBtn').disabled = false;
                                document.getElementById('openaiVideoProgress').style.display = 'none';
                            }
                        } catch (error) {
                            console.error('‚ùå FALLBACK check failed:', error);
                            alert('Unable to verify video creation. Please check the server and try again.');
                            document.getElementById('createOpenAIVideoBtn').disabled = false;
                            document.getElementById('openaiVideoProgress').style.display = 'none';
                        }
                    }, 5000); // Wait 5 seconds after stream ends
                }

            } catch (error) {
                console.error('OpenAI Video creation error:', error);
                alert('Error creating HD video: ' + error.message + '\n\nDebugging steps:\n1. Check if Flask server is running\n2. Open browser console (F12) for detailed errors\n3. Try the "Test Video Display" button first\n4. Check server terminal for "Moviepy - Done!" message');
                document.getElementById('createOpenAIVideoBtn').disabled = false;
                document.getElementById('openaiVideoProgress').style.display = 'none';
            }
        }

        // Test OpenAI connection and TTS functionality
        async function testOpenAIConnection() {
            console.log('üß™ Testing OpenAI connection...');
            alert('Testing OpenAI connection - check console for details');
            
            try {
                const response = await fetch('/manga/test-openai', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ test: true })
                });
                
                const result = await response.text();
                console.log('üß™ OpenAI test result:', result);
                alert('OpenAI test completed - check console for details');
                
            } catch (error) {
                console.error('üß™ OpenAI test failed:', error);
                alert('OpenAI test failed: ' + error.message);
            }
        }

        function handleOpenAIProgressUpdate(data) {
            console.log('üéØ handleOpenAIProgressUpdate called with:', data);
            
            if (data.progress) {
                console.log('üìä Updating progress:', data.progress, '%');
                updateOpenAIProgress(data.progress, data.message || '');
            }

            if (data.step) {
                console.log('üë£ Updating step:', data.step);
                updateOpenAIProgressStep(data.step, 'active');
                if (data.step > 1) {
                    updateOpenAIProgressStep(data.step - 1, 'completed');
                }
            }

            if (data.complete && data.video_url) {
                console.log('üéâ COMPLETION DETECTED - calling showOpenAIVideoResult!');
                console.log('üé¨ Video data:', data);
                showOpenAIVideoResult(data);
            }

            if (data.error) {
                console.error('‚ùå Error received:', data.error);
                alert('OpenAI Video creation failed: ' + data.error);
                document.getElementById('createOpenAIVideoBtn').disabled = false;
                document.getElementById('openaiVideoProgress').style.display = 'none';
            }
        }

        function updateOpenAIProgress(percentage, message) {
            document.getElementById('openaiProgressFill').style.width = percentage + '%';
            document.getElementById('openaiProgressText').textContent = message;
        }

        function updateOpenAIProgressStep(stepNumber, status) {
            const step = document.getElementById('openaiStep' + stepNumber);
            if (step) {
                step.className = 'progress-step ' + status;
                
                const messages = {
                    1: 'üîß Preparing components',
                    2: 'üé§ Generating HD audio (with Windows TTS backup)',
                    3: 'üé® Processing images',
                    4: 'üé¨ Creating video',
                    5: '‚ú® Finalizing'
                };

                if (status === 'completed') {
                    step.textContent = '‚úÖ ' + messages[stepNumber].substring(2);
                } else if (status === 'active') {
                    step.textContent = 'üîÑ ' + messages[stepNumber].substring(2);
                }
            }
        }

        function showOpenAIVideoResult(data) {
            console.log('üé¨ showOpenAIVideoResult called with data:', data);
            
            // Mark completion to prevent fallback checks
            window.openaiVideoCompleted = true;
            
            // Store video URL for download function
            window.currentOpenAIVideoUrl = data.video_url;
            
            // Hide progress and show result
            console.log('üëª Hiding progress, showing result...');
            document.getElementById('openaiVideoProgress').style.display = 'none';
            document.getElementById('openaiVideoResult').style.display = 'block';
            
            console.log('‚úÖ Result section should now be visible');
            
            // Set video source with proper loading
            const videoPlayer = document.getElementById('openaiVideoPlayer');
            const videoSource = document.getElementById('openaiVideoSource');
            
            // CLEAR ANY EXISTING VIDEO COMPLETELY to prevent caching
            videoPlayer.pause();
            videoPlayer.removeAttribute('src');
            videoSource.removeAttribute('src');
            videoPlayer.load(); // Reset player state
            
            // Add multiple cache-busting parameters
            const cacheBuster = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const videoUrl = data.video_url + '?v=' + cacheBuster + '&nocache=' + Date.now();
            console.log('üé¨ Setting NEW video URL with cache-busting:', videoUrl);
            
            videoSource.src = videoUrl;
            
            // Ensure video loads properly and has audio
            videoPlayer.load();
            
            // Enable audio (remove mute if present)
            videoPlayer.muted = false;
            videoPlayer.volume = 0.8;
            
            // Add enhanced error handling for video loading
            videoPlayer.onerror = function(e) {
                console.error('‚ùå Video loading error:', e);
                console.error('‚ùå Video error details:', videoPlayer.error);
                alert('Error loading video. Please check if the video file was created properly.');
            };
            
            // Set video dimensions explicitly
            videoPlayer.style.width = '100%';
            videoPlayer.style.height = 'auto';
            videoPlayer.style.minHeight = '400px';
            videoPlayer.style.maxWidth = '800px';
            
            // Try to load metadata and check for audio
            videoPlayer.addEventListener('loadedmetadata', function() {
                console.log('‚úÖ OpenAI Video metadata loaded successfully');
                console.log('üì∫ Video dimensions:', videoPlayer.videoWidth, 'x', videoPlayer.videoHeight);
                console.log('‚è±Ô∏è Video duration:', videoPlayer.duration);
                
                // Check for audio tracks
                const hasAudio = videoPlayer.audioTracks ? videoPlayer.audioTracks.length > 0 : 'unknown';
                console.log('üîä Audio tracks detected:', hasAudio);
                
                // Try to play a bit to check audio
                setTimeout(() => {
                    if (videoPlayer.currentTime === 0) {
                        videoPlayer.currentTime = 0.1;
                        videoPlayer.play().then(() => {
                            console.log('‚úÖ Video playback started successfully');
                            setTimeout(() => {
                                videoPlayer.pause();
                                videoPlayer.currentTime = 0;
                            }, 1000);
                        }).catch(err => {
                            console.log('‚ö†Ô∏è Autoplay blocked (normal):', err);
                        });
                    }
                }, 500);
            });

            // Update stats
            document.getElementById('openaiResultDuration').textContent = data.duration || '-';
            document.getElementById('openaiResultQuality').textContent = data.quality || '-';
            document.getElementById('openaiResultFileSize').textContent = data.file_size || '-';
            
            if (data.enhanced) {
                // Show which TTS method was actually used
                let audioStatus = data.audio_quality || 'HD TTS';
                if (data.tts_method) {
                    if (data.tts_method === 'edge') {
                        audioStatus = 'üîä Windows Edge TTS (Fallback)';
                    } else if (data.tts_method === 'openai') {
                        audioStatus = '‚ú® OpenAI HD TTS (Primary)';
                    } else if (data.tts_method === 'mixed') {
                        audioStatus = 'üé§ Mixed TTS Sources';
                    } else {
                        audioStatus = `üé§ ${data.tts_method} TTS`;
                    }
                }
                document.getElementById('openaiResultAudio').textContent = audioStatus;
            }

            document.getElementById('createOpenAIVideoBtn').disabled = false;
        }

        function downloadOpenAIVideo() {
            if (window.currentOpenAIVideoUrl) {
                const a = document.createElement('a');
                a.href = window.currentOpenAIVideoUrl;
                a.download = 'manga_video_hd_' + new Date().toISOString().slice(0,10) + '.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        function shareOpenAIVideo() {
            if (navigator.share && window.currentOpenAIVideoUrl) {
                navigator.share({
                    title: 'My HD Manga Recap Video',
                    text: 'Check out this high-quality manga recap video I created with OpenAI!',
                    url: window.currentOpenAIVideoUrl
                });
            } else {
                // Fallback - copy URL to clipboard
                navigator.clipboard.writeText(window.currentOpenAIVideoUrl).then(() => {
                    alert('Video URL copied to clipboard!');
                });
            }
        }

        function createAnotherOpenAIVideo() {
            document.getElementById('openaiVideoResult').style.display = 'none';
            document.getElementById('openaiVideoProgress').style.display = 'none';
            document.getElementById('createOpenAIVideoBtn').disabled = false;
            document.getElementById('checkVideoBtn').style.display = 'none';
        }
        
        // Manual video check function for when SSE fails
        async function manualVideoCheck() {
            console.log('üîç Manual video check requested...');
            if (!window.currentSessionId) {
                alert('No session found. Please upload images and generate a recap first.');
                return;
            }
            
            try {
                const checkResponse = await fetch(`/manga/uploads/${window.currentSessionId}/manga_video.mp4`, {
                    method: 'HEAD'
                });
                
                if (checkResponse.ok) {
                    console.log('‚úÖ Video found! Displaying...');
                    const videoUrl = `/manga/uploads/${window.currentSessionId}/manga_video.mp4`;
                    showOpenAIVideoResult({
                        video_url: videoUrl,
                        complete: true,
                        duration: 'Unknown',
                        quality: 'HD',
                        file_size: 'Unknown',
                        audio_quality: 'HD TTS',
                        tts_method: 'openai',
                        enhanced: true
                    });
                    
                    // Hide the manual check button
                    document.getElementById('checkVideoBtn').style.display = 'none';
                } else {
                    alert('Video not found. It may still be processing, or creation may have failed.');
                }
            } catch (error) {
                console.error('Manual check failed:', error);
                alert('Unable to check for video. Please verify the server is running.');
            }
        }
        async function checkForCompletedVideo() {
            if (!window.currentSessionId) {
                alert('No session ID found. Please upload images first.');
                return;
            }
            
            console.log('üîç Manually checking for completed video...');
            
            try {
                const videoUrl = `/manga/uploads/${window.currentSessionId}/manga_video_hq.mp4`;
                const checkResponse = await fetch(videoUrl, { method: 'HEAD' });
                
                if (checkResponse.ok) {
                    console.log('üéâ MANUAL CHECK: Video found! Displaying result...');
                    showOpenAIVideoResult({
                        video_url: videoUrl,
                        complete: true,
                        duration: 'Unknown',
                        quality: 'HD',
                        file_size: 'Unknown',
                        audio_quality: 'HD TTS',
                        tts_method: 'openai',
                        enhanced: true
                    });
                    document.getElementById('checkVideoBtn').style.display = 'none';
                } else {
                    alert('No completed video found. The video may still be processing or failed to create.');
                }
            } catch (error) {
                console.error('‚ùå Manual check failed:', error);
                alert('Unable to check for video. Please ensure the server is running.');
            }
        }
        
        // Test function to verify video display works
        function testVideoDisplay() {
            console.log('üß™ Testing video display manually...');
            
            if (!window.currentSessionId) {
                alert('Please upload images and generate a recap first to create a session.');
                return;
            }
            
            // Test with a dummy video URL to see if the display logic works
            const testVideoData = {
                video_url: `/manga/uploads/${window.currentSessionId}/manga_video_hq.mp4`,
                complete: true,
                duration: '1:30',
                quality: 'HD',
                file_size: '15.2 MB',
                audio_quality: 'HD TTS',
                tts_method: 'openai',
                enhanced: true
            };
            
            console.log('üß™ Calling showOpenAIVideoResult with test data:', testVideoData);
            showOpenAIVideoResult(testVideoData);
        }

        function testSpecificVideo() {
            console.log('üß™ Testing specific video display...');
            
            // Test with the actual session ID that has a video
            const testVideoData = {
                video_url: '/manga/uploads/d1db48cd-811a-457e-bfac-b3f7b2631ee8/manga_video.mp4',
                complete: true,
                duration: '0:42',
                quality: '720p HD',
                file_size: '15.2 MB',
                audio_quality: 'OpenAI HD TTS',
                enhanced: true
            };
            
            console.log('üß™ Testing showOpenAIVideoResult with actual video:', testVideoData);
            showOpenAIVideoResult(testVideoData);
        }

        async function checkVideoAudio() {
            console.log('üîä Checking video audio for session d1db48cd-811a-457e-bfac-b3f7b2631ee8...');
            
            // Also check current session if different
            const sessionToCheck = window.currentSessionId || 'd1db48cd-811a-457e-bfac-b3f7b2631ee8';
            console.log('üîç Using session ID:', sessionToCheck);
            
            // Try different possible video filenames (including timestamped ones)
            const possibleVideos = [
                `/manga/uploads/${sessionToCheck}/manga_video.mp4`,
                `/manga/uploads/${sessionToCheck}/manga_video_hq.mp4`
            ];
            
            // Also try to detect timestamped videos by checking for common patterns
            const timestampPatterns = [
                `manga_video_hq_${new Date().toISOString().slice(0,10).replace(/-/g, '')}_*.mp4`,
                'manga_video_hq_2024*.mp4',
                'manga_video_hq_2025*.mp4'
            ];
            
            console.log('üîç Checking video files:', possibleVideos);
            
            let foundVideos = [];
            
            for (const videoUrl of possibleVideos) {
                try {
                    console.log(`üé¨ Testing video: ${videoUrl}`);
                    
                    // Check if the video file exists
                    const response = await fetch(videoUrl, { method: 'HEAD' });
                    
                    if (response.ok) {
                        console.log(`‚úÖ Video found: ${videoUrl}`);
                        foundVideos.push({
                            url: videoUrl,
                            lastModified: response.headers.get('last-modified'),
                            size: response.headers.get('content-length')
                        });
                        
                    } else {
                        console.log(`‚ùå Video not found: ${videoUrl} (Status: ${response.status})`);
                    }
                    
                } catch (error) {
                    console.error(`‚ùå Error testing ${videoUrl}:`, error);
                }
            }
            
            if (foundVideos.length === 0) {
                alert('No video files found for the session.\n\nThis suggests:\n1. Video creation may have failed\n2. Files were moved/deleted\n3. Wrong session ID\n\nTry creating a new video or check the server logs.');
                return;
            }
            
            // Sort by most recent (if last-modified available)
            foundVideos.sort((a, b) => {
                if (a.lastModified && b.lastModified) {
                    return new Date(b.lastModified) - new Date(a.lastModified);
                }
                return 0;
            });
            
            console.log('üé¨ Found videos:', foundVideos);
            
            // Test the most recent video
            const newestVideo = foundVideos[0];
            const videoUrl = newestVideo.url;
            
            // Create a temporary video element to test audio
            const testVideo = document.createElement('video');
            testVideo.src = videoUrl + '?test=' + Date.now(); // Cache-busting for test
            testVideo.muted = false;
            testVideo.style.display = 'none';
            document.body.appendChild(testVideo);
            
            // Wait for metadata to load
            testVideo.addEventListener('loadedmetadata', function() {
                console.log('üì∫ Video metadata loaded:');
                console.log('- Duration:', testVideo.duration, 'seconds');
                console.log('- Video size:', testVideo.videoWidth, 'x', testVideo.videoHeight);
                console.log('- Has audio tracks:', testVideo.audioTracks ? testVideo.audioTracks.length : 'Unknown');
                console.log('- Last modified:', newestVideo.lastModified || 'Unknown');
                console.log('- File size:', newestVideo.size ? (parseInt(newestVideo.size) / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown');
                
                // Try to play a small portion to test audio
                testVideo.currentTime = 1; // Skip to 1 second
                testVideo.play().then(() => {
                    console.log('üîä Video is playing. Checking for audio...');
                    
                    setTimeout(() => {
                        // Check if there's actual audio data
                        console.log('üéµ Audio context test:');
                        console.log('- Muted:', testVideo.muted);
                        console.log('- Volume:', testVideo.volume);
                        console.log('- Current time:', testVideo.currentTime);
                        
                        // Show the video in the interface for testing
                        showOpenAIVideoResult({
                            video_url: videoUrl,
                            complete: true,
                            duration: `${Math.floor(testVideo.duration / 60)}:${Math.floor(testVideo.duration % 60).toString().padStart(2, '0')}`,
                            quality: testVideo.videoHeight + 'p HD',
                            file_size: newestVideo.size ? (parseInt(newestVideo.size) / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown',
                            audio_quality: 'Testing Audio...',
                            enhanced: true
                        });
                        
                        testVideo.pause();
                        document.body.removeChild(testVideo);
                        
                        let videoInfo = `Video found and loaded successfully!\n\n`;
                        videoInfo += `File: ${videoUrl}\n`;
                        videoInfo += `Duration: ${testVideo.duration.toFixed(2)} seconds\n`;
                        videoInfo += `Resolution: ${testVideo.videoWidth}x${testVideo.videoHeight}\n`;
                        videoInfo += `Size: ${newestVideo.size ? (parseInt(newestVideo.size) / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown'}\n`;
                        videoInfo += `Modified: ${newestVideo.lastModified || 'Unknown'}\n`;
                        
                        if (foundVideos.length > 1) {
                            videoInfo += `\nNote: Found ${foundVideos.length} videos, showing the newest one.`;
                        }
                        
                        videoInfo += `\n\nThe video is now displayed in the interface. Try playing it to test audio.`;
                        
                        alert(videoInfo);
                        
                    }, 2000);
                    
                }).catch(err => {
                    console.error('‚ùå Video play failed:', err);
                    alert(`Video found but couldn't play: ${err.message}`);
                    document.body.removeChild(testVideo);
                });
            });
            
            testVideo.addEventListener('error', function(e) {
                console.error('‚ùå Video loading error:', e);
                alert(`Video file exists but couldn't load: ${testVideo.error ? testVideo.error.message : 'Unknown error'}`);
                document.body.removeChild(testVideo);
            });
        }
    </script>
    
</body>
</html>